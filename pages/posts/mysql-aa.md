---
title: MySQL
date: 2025-07-10
updated: 2025-07-10
categories: 数据库
tags:
  - MySQL
  - 后端
  - 数据库
  - Java
---



# MySQL


## 事务

### 简介

**事务** 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作**要么同时成功，要么同时失败**。

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-16_20-17-45.png)

默认MySQL的事务是自动提交的，也就是说，当执行一条DML(增删改)语句，MySQL会立即隐式的提交事务，这意味着如果有一条DML语句执行失败，整个事务会被回滚。


查看/设置事务提交方式
```sql
-- 1自动提交 0手动提交
select @@autocommit;

SET @@autocommit = 0;

-- 提交事务
COMMIT;

-- 回滚事务
ROLLBACK;
```

开启事务
```sql
START TRANSACTION;

BEGIN;
```

### 四大特性


- 原子性(Atomicity): 事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
- 一致性(Consistency): 事务完成时，数据库从一个一致的状态转变为另一个一致的状态。这意味着事务 在执行前后，不能破坏数据库数据的完整性和一致性，必须使所有的数据都保持一致状态。
- 隔离性(solation): 数据库系统提供的隔离机制，多个事务可以同时在数据库中执行，但它们之间应该是相互隔离的，一个事务的执行 不应该影响其他事务的执行，保证事务在不受外部并发操作影响的 独立环境下运行
- 持久性(Durability): 事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。即使系统发生故障或重启，也应该能够保持数据的持久性。

### 并发事务问题

- 脏读（Dirty Read）： 脏读发生在一个事务读取了另一个事务尚未提交的数据。如果这个事务最终回滚，读取到的数据就是无效的。

解决方法： 设置事务隔离级别，使用更高的隔离级别，如 READ COMMITTED， REPEATABLE READ，SERIALIZABLE 可以避免脏读。

- 不可重复读（Non-Repeatable Read）： 不可重复读发生在一个事务内，先后读取同一条记录，但两个相同查询读取的数据不同，因为在两次查询之间，另一个事务修改了数据。

解决方法： 设置隔离级别，如：REPEATABLE READ， Serializable，或者使用锁定机制。

- 幻读（Phantom Read）： 幻读 发生在一个事务内的两个相同条件查询返回了不同的结果，因为在两次查询之间，另一个事务插入或删除了数据，导致结果集发生变化，好像出现了‘幻影’。一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在。

解决方法： 设置隔离级别Serializable，通过强制事务串行化执行来避免幻读，或者使用锁定机制。

- 丢失更新（Lost Update）： 丢失更新发生在两个事务同时尝试更新相同数据，但只有一个更新生效，导致另一个更新的结果丢失。

解决方法： 使用锁定机制，如悲观锁或乐观锁，确保同时只有一个事务可以更新数据。


### 事务隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| --------- | ---- | ---------- | ---- |
| READ-UNCOMMITTED | √| √| √ |
| READ-COMMITTED | × |√ |√ |
| REPEATABLE-READ | ×| × | √ |
| SERIALIZABLE  |× |× |× |


事务隔离级别越严格，数据越安全，但数据库效率越低。 MySQL 默认的事务隔离级别是：`REPEATABLE-READ`可重复读级别，简称 `RR` 级别，会出现幻读问题。

```sql
-- 查看事务隔离级别
SELECT @@TRANSACTION_ISOLATION;

-- 设置事务隔离级别
SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ-UNCOMMITTED|READ-COMMITTED|REPEATABLE-READ|SERIALIZABLE];
```

`READ UNCOMMITTED（读未提交）`： 允许一个事务读取另一个事务未提交的数据。这是最低的隔离级别，不提供任何隔离保护。 可能出现脏读、不可重复读和幻读的问题。

`READ COMMITTED（读已提交）`： 允许一个事务只能读取其他事务已经提交的数据，看不到其他未提交事务的修改。 可能出现不可重复读和幻读的问题，但解决了脏读的问题。

`REPEATABLE READ（可重复读）`： 保证一个事务在其生命周期内多次读取相同的数据，将返回相同的结果，即使其他事务已经修改了数据。其他事务的插入操作将被阻止。 可能出现幻读的问题，但解决了脏读和不可重复读的问题。

`SERIALIZABLE（串行化）`： 提供最高的隔离级别，确保事务之间完全隔离。事务按顺序执行，所有事务都像是按照顺序串行执行的，没有并发。避免了脏读、不可重复读和幻读的问题，但会降低并发性能。 虽然能保证数据的一致性，但可能会导致大量的事务等待，降低了系统的吞吐量和性能。



## 存储引擎


### MySQL体系结构
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-16_23-23-25.png)

- 连接层
最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

- 服务层
第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。

- 引擎层
存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。存储引擎层负责管理数据存储、**索引**实现和管理、并发控制和事务处理。它与底层文件系统交互，以高效地读取和写入数据。

- 存储层
主要是将数据存储在文件系统之上，并完成与存储引擎的交互。



**存储引擎简介**

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。

`mysql5.5`版本之后，默认的存储引擎为 `InnoDB`，之前的版本默认的存储引擎为 `MyISAM`。

查看当前数据库支持的存储引擎


```sql
SHOW ENGINES;
```


### InnoDB

InnoDB 是 MySQL 5.5 版本之后默认的存储引擎，它支持事务处理、行级锁定和外键完整性。InnoDB 是一个高性能的存储引擎，它在性能和并发方面都有很大的优势。



特点:
- DML操作遵循ACID模型，支持**事务**;
- **行级锁**，提高并发访问性能;
- 支持**外键 FOREIGN KEY**约束，保证数据的完整性和正确性;


文件：

`xxx.ibd`:xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构(frm、mysql8之后sdi)、数据和索引;

参数:innodb_file_per_table



:::info
mysql8.0默认使用的是innodb_file_per_table=ON，表示每个表对应一个表空间文件，而mysql5.7默认使用的是innodb_file_per_table=OFF，表示所有表共用一个表空间文件。
:::


查看表空间文件
```sql
ibd2sdi account

-- 在该ibd文件目录下cmd，命令： idb2sdi 表名
```

InnoDB逻辑存储结构
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-16_23-58-20.png)

- 区(Extent)：一个区大小是固定的，为1M，一个区可以包含64个页。
- 页(Page)：InnoDB存储引擎将数据存储在页中，大小也是固定的，页的大小为16KB，即65536字节。页里面即使row数据。


### MyISAM

`MyISAM`是`MySQL`早期的默认存储引擎。

**特点**
- 不支持事务，不支持外键
- 支持表锁，不支持行锁
- 访问速度快

在磁盘中所涉及到的文件有`xxxx.MYD`,`xxxx.MYI`和`xxxx.SDI`三个文件。

`xxxx.MYD`表中存放的数据，`xxxx.MYI`文件存储表的索引信息，`xxxx.SDI`表结构信息。


### Memory

`Memory`引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用

**特点**
- 内存存放
- hash索引(默认)

**文件**

`xxx.sdi`:存储表结构信息


**区别**
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_21-02-07.png)


### 存储引擎选择

在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

- `InnoDB`:是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。
- `MyISAM`:如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。
- `MEMORY`:将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。


## 索引的数据结构

### 为什么使用索引

索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则`通过索引查找`相关数据，如果不符合则需要`全表扫描`，即需要一条一条地查找记录，直到找到与条件符合的记录。

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/wechat_2025-07-17_215138_204.png)

如上图所示，数据库没有索引的情况下，数据`分布在硬盘不同的位置上面`，读取数据时，摆臂需要前后摆动查询数据，这样操作非常消耗时间。如果`数据顺序摆放`，那么也需要从1到6行按顺序读取，这样就相当于进行了6次IO操作，`依旧非常耗时`。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col 2 = 89 这条记录，就要逐行去查找、去比较。从Col 2 = 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有上千万条数据，就意味着要做`很多很多次硬盘I/0`才能找到。现在要查找 Col 2 = 89 这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间就是磁盘I/O（涉及到磁盘的旋转时间（速度较快），磁头的寻道时间(速度慢、费时)）

假如给数据使用 `二叉树` 这样的数据结构进行存储，如下图所示

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_21-52-44.png)

对字段 Col 2 添加了索引，就相当于在硬盘上为 Col 2 维护了一个索引的数据结构，即这个 `二叉搜索树`。二叉搜索树的每个结点存储的是 `(K, V) 结构`，key 是 Col 2，value 是该 key 所在行的文件指针（地址）。比如：该二叉搜索树的根节点就是：`(34, 0x07)`。现在对 Col 2 添加了索引，这时再去查找 Col 2 = 89 这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找）。读 34 到内存，89 > 34; 继续右侧数据，读 89 到内存，89==89；找到数据返回。找到之后就根据当前结点的 value 快速定位到要查找的记录对应的地址。我们可以发现，只需要 `查找两次` 就可以定位到记录的地址，查询速度就提高了。

这就是我们为什么要建索引，目的就是为了 `减少磁盘I/O的次数`，加快查询速率。


### 索引及其优缺点


**索引概述**

MySQL官方对索引的定义为：**索引（Index）是帮助MySQL高效获取数据的数据结构**。

**索引的本质**：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 `高级查找算法` 。

`索引是在存储引擎中实现的`，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 `最大索引数` 和 `最大索引长度`。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。

#### 优点
（1）类似大学图书馆建书目索引，提高数据检索的效率，**降低数据库的IO成本** ，这也是创建索引最主 要的原因。

（2）通过创建唯一索引，可以保证数据库表中每一行**数据的唯一性** 。

（3）在实现数据的 参考完整性方面，可以**加速表和表之间的连接** 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。

（4）在使用分组和排序子句进行数据查询时，可以显著**减少查询中分组和排序的时间** ，降低了CPU的消耗。

#### 缺点
增加索引也有许多不利的方面，主要表现在如下几个方面：

（1）创建索引和维护索引要 **耗费时间** ，并 且随着数据量的增加，所耗费的时间也会增加。

（2）索引需要占 **磁盘空间** ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。

（3）虽然索引大大提高了查询速度，同时却会 **降低更新表的速度** 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 因此，选择使用索引时，需要综合考虑索引的优点和缺点。

因此，选择使用索引时，需要综合考虑索引的优点和缺点。

:::tip
提示：

索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。
:::


## InnoDB中索引的推演

### 索引之前的查找

先来看一个精确匹配的例子：

```sql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```

**1. 在一个页中的查找**

假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：

- 以主键为搜索条件

    可以在页目录中使用 **二分法** 快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。

- 以其他列作为搜索条件

    因为在数据页中并没有对非主键列简历所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从 **最小记录** 开始 **依次遍历单链表中的每条记录**， 然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。

2. 在很多页中查找
在很多页中查找记录的活动可以分为两个步骤：

    1. 定位到记录所在的页。
    2. 从所在的页内中查找相应的记录。



在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 `从第一个页`沿着`双向链表` 一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 `超级耗时` 的。如果一个表有一亿条记录呢？此时 `索引` 应运而生。

### 设计索引

建一个表：
```sql
mysql> CREATE TABLE index_demo(
-> c1 INT,
-> c2 INT,
-> c3 CHAR(1),
-> PRIMARY KEY(c1)
-> ) ROW_FORMAT = Compact;
```
这个新建的 `index_demo` 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用 `Compact` 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-45-21.png)

我们只在示意图里展示记录的这几个部分：

- `record_type` ：记录头信息的一项属性，表示记录的类型， `0` 表示普通记录、 `2` 表示最小记录、 `3` 表示最大记录、 `1` 暂时还没用过，下面讲。
- `next_record` ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁。
- `各个列的值` ：这里只记录在 `index_demo` 表中的三个列，分别是 `c1` 、 `c2` 和 `c3` 。
- `其他信息` ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-47-33.png)

把一些记录放到页里的示意图就是：

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-48-06.png)


#### 一个简单的索引设计方案


我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 `想快速的定位到需要查找的记录在哪些数据页` 中该咋办？我们可以为快速定位记录所在的数据页而`建立一个目录` ，建这个目录必须完成下边这些事：

- **下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。**
- **给所有的页建立一个目录项。**

假设：每个数据结构最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。
```sql
INSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y');
```

那么这些记录以及按照主键值的大小串联成一个单向链表了，如图所示：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-53-46.png)

从图中可以看出来， `index_demo` 表中的3条记录都被插入到了编号为10的数据页中了。此时我们再来插入一条记录
```sql
INSERT INTO index_demo VALUES(4, 4, 'a');
```
因为 **页10** 最多只能放3条记录，所以我们不得不再分配一个新页：这个过程称为 `页分裂`。

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-55-07.png)

注意：新分配的 **数据页编号可能并不是连续的**。它们只是通过维护者上一个页和下一个页的编号而建立了 `链表` 关系。另外，**页10**中用户记录最大的主键值是5，而页28中有一条记录的主键值是4，因为5>4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次 `记录移动`，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-57-30.png)

这个过程表明了在对页中的记录进行增删改查操作的过程中，我们必须通过一些诸如 `记录移动` 的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。

- **给所有的页建立一个目录项。**

由于数据页的 **编号可能是不连续** 的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-59-17.png)

我们需要给它们做个 目录，每个页对应一个目录项，每个目录项包括下边两个部分：

    1）页的用户记录中最小的主键值，我们用 key 来表示。

    2）页号，我们用 page_on 表示。



所以我们为上边几个页做好的目录就像这样子:
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_22-51-12.png)

以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主 键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：

1. 先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 < 20 < 209 ），它对应的页是 页9 。
2. 再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。

至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 `索引` 。



### InnoDB中的索引方案


**① 迭代1次：目录项纪录的页**

InnoDB怎么区分一条记录是普通的 **用户记录** 还是 **目录项记录** 呢？使用记录头信息里的 `record_type` 属性，它的各自取值代表的意思如下：

- 0：普通的用户记录
- 1：目录项记录
- 2：最小记录
- 3：最大记录

我们把前边使用到的目录项放到数据页中的样子就是这样：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_23-25-01.png)


从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 **目录项记录** 和普通的 **用户记录** 的不同点：

- **目录项记录** 的 record_type 值是1，而 **普通用户记录** 的 record_type 值是0。
- 目录项记录只有 **主键值和页的编号** 两个列，而普通的用户记录的列是用户自己定义的，可能包含 **很多列** ，另外还有InnoDB自己添加的隐藏列。
- 了解：记录头信息里还有一个叫 min_rec_mask 的属性，只有在存储 **目录项记录** 的页中的主键值最小的 **目录项记录** 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。

**相同点**：两者用的是一样的数据页，都会为主键值生成 **Page Directory （页目录）**，从而在按照主键值进行查找时可以使用 `二分法` 来加快查询速度。

现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

1. 先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 < 20 < 209 ，所以定位到对应的记录所在的页就是页9。
2. 再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。

**② 迭代2次：多个目录项纪录的页**
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_23-29-26.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：

- 为存储该用户记录而新生成了 `页31` 。
- 因为原先存储目录项记录的 `页30的容量已满` （我们前边假设只能存储4条目录项记录），所以不得 不需要一个新的 `页32` 来存放 `页31` 对应的目录项。

现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 `20` 的记录为例：

1. 确定 目录项记录页 我们现在的存储目录项记录的页有两个，即 `页30` 和 `页32` ，又因为页30表示的目录项的主键值的 范围是 `[1, 320)` ，页32表示的目录项的主键值不小于 `320` ，所以主键值为 `20` 的记录对应的目 录项记录在 `页30` 中。
2. 通过目录项记录页 `确定用户记录真实所在的页` 。 在一个存储 `目录项记录` 的页中通过主键值定位一条目录项记录的方式说过了。
3. 在真实存储用户记录的页中定位到具体的记录。


**③ 迭代3次：目录项记录页的目录页**

如果我们表中的数据非常多则会`产生很多存储目录项记录的页`，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个`更高级的目录`，就像是一个多级目录一样，`大目录里嵌套小目录`，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：


![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_23-33-17.png)

如图，我们生成了一个存储更高级目录项的 `页33` ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 `[1, 320)` 之间，则到页30中查找更详细的目录项记录，如果主键值 `不小于320` 的 话，就到页32中查找更详细的目录项记录。

我们可以用下边这个图来描述它：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-17_23-34-47.png)

这个数据结构，它的名称是 `B+树` 。

#### B+Tree

为什么b+树最多只有4层？

一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放**用户记录** 的叶子节点代表的**数据页**可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的**数据页**可以存 放 1000条目录项记录 ，那么：

- 如果B+树只有1层，也就是只有1个用于存放**用户记录**的节点，最多能存放 100 条记录。
- 如果B+树有2层，最多能存放 1000×100=10,0000  十万条记录。
- 如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 一亿条记录。
- 如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记录！

你的表里能存放 100000000000 条记录吗？所以一般情况下，我们用到的 `B+树都不会超过4层` ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个`目录项页`和一个`用户记录`页），又因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 **二分法** 实现快速 定位记录。


### 常见索引概念

索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。

#### 聚簇索引

聚簇索引并不是一种单独的索引类型，而是`一种数据存储方式`（所有的**用户记录**都存储在了叶子结点），也就是所谓的 `索引即数据，数据即索引`。

>术语"聚簇"表示当前数据行和相邻的键值聚簇的存储在一起

特点：

- 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
    - `页内` 的记录是按照主键的大小顺序排成一个 `单向链表` 。
    - 各个存放 `用户记录的页` 也是根据页中用户记录的主键大小顺序排成一个 `双向链表` 。
    - 存放 `目录项记录的页` 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 `双向链表` 。

- B+树的 `叶子节点` 存储的是完整的用户记录。

    所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个`聚簇索引`的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX 语句去创建， `InnDB` 存储引擎会 `自动` 的为我们创建聚簇索引。

**优点：**

- `数据访问更快` ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
- 聚簇索引对于主键的 `排序查找` 和 `范围查找` 速度非常快
- 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 `节省了大量的io操作` 。

**缺点：**

- `插入速度严重依赖于插入顺序` ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键
- `更新主键的代价很高` ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新
- `二级索引访问需要两次索引查找` ，第一次找到主键值，第二次根据主键值找到行数据


#### 二级索引（辅助索引、非聚簇索引）

如果我们想以别的列作为搜索条件该怎么办？肯定不能是从头到尾沿着链表依次遍历记录一遍。

答案：我们可以`多建几颗B+树`，不同的B+树中的数据采用不同的排列规则。比方说我们用c2列的大小作为数据页、页中记录的排序规则，再建一课B+树，效果如下图所示：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-18_00-26-18.png)

这个B+树与上边介绍的聚簇索引有几处不同：


- 使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义:
    - 页内的记录是按照c2列的大小顺序排成一个 `单向链表`。
    - 各个存放 `用户记录的页` 也是根据页中记录的c2列大小顺序排成一个 `双向链表` 。
    - 存放 `目录项记录的页` 分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个 `双向链表`。
- B+树的叶子节点存储的并不是完整的用户记录，而只是 `c2列+主键` 这两个列的值
- 目录项记录中不再是 `主键+页号` 的搭配，而变成了 `c2列+页号` 的搭配。


所以如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树了。以查找c2列的值为`4`的记录为例，查找过程如下

1. 确定 `目录项记录页`

    根据 `根页面`，也就是`页44`，可以快速定位到 `目录项记录`所在的页为`页42`(因为`2<4<9`)。

2. 通过 `目录项记录` 页确定用户记录真实所在的页

在`页42` 中可以快速定位到实际存储用户记录的页，但是由于`c2` 列并没有唯一性约束，所以 `c2` 列值为`4`的记录可能分布在多个数据页中，又因为`2<4≤4`，所以确定实际存储用户记录的页在 `页34` 和 `页35` 中。

3. 在真实存储用户记录的页中定位到具体的记录。

到 `页34` 和 `页35` 中定位到具体的记录。

4. 但是这个B+树的叶子节点中的记录只存储了 `c2`和 `c1`(也就是 `主键`)两个列，所以我们必须再根据主键值4去聚簇索引中再查找一遍完整的用户记录。

---

概念：**回表**

我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到 `聚簇索引` 中再查一遍，这个过程称为 `回表` 。也就是根据c2列的值查询一条完整的用户记录需要使用到 `2` 棵B+树！

---

>问题：为什么我们还需要一次 `回表` 操作呢？直接把完整的用户记录放到叶子节点不OK吗？

回答：

如果把完整的用户记录放到叶子结点是可以不用回表。但是太占地方了，相当于每建立一课B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。
比如表中有10个字段，意味着把每个字段都要拷贝一遍，放到叶子节点，叶子节点又完整的存储了表中所有记录。而且一张表是可以有多个聚簇索引，假如有三个聚簇索引，
每个二级索引都存储了一份完整的表记录，那表记录一共存储了四份，这就乱了，冗余特别大；

因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引，或者辅助索引。由于使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为c2列建立的索引。

---

非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-18_00-38-17.png)

---

小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：

1. 聚簇索引的`叶子节点`存储的就是我们的`数据记录`, 非聚簇索引的叶子节点存储的是`数据位置`。非聚簇索引不会影响数据表的物理存储顺序。
2. 一个表`只能有一个聚簇索引`，因为只能有一种排序存储的方式，但可以有`多个非聚簇索引`，也就是多个索引目录提供数据检索。
3. 使用聚簇索引的时候，数据的`查询效率高`，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。

#### 联合索引
联合索引就是非聚簇索引中的一种

联合索引是指对表中的多个列组合起来创建的索引。


我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 `c2和c3列` 的大小进行排序，这个包含两层含义：

- 先把各个`记录`和`页`按照c2列进行排序。
- 在记录的c2列相同的情况下，采用c3列进行排序

为c2和c3建立的索引的示意图如下：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-18_20-13-34.png)

如图所示，我们需要注意以下几点：

- 每条`目录项`都由c2、c3、`页号`这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序
- B+树叶子节点处的`用户记录`由c2、c3和`主键c1`列组成

注意一点，以c2和c3列的大小为排序规则建立的B+树称为 `联合索引` ，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：

- 建立 `联合索引` 只会建立如上图一样的1棵B+树。
- 为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。

---

### InnoDB的B+树索引的注意事项

#### 1. 根页面位置万年不动

实际上B+树的形成过程是这样的：

- 每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个 `根结点` 页面。最开始表中没有数据的时候，每个B+树索引对应的 `根结点` 中即没有`用户记录`，也没有`目录项`记录。
- 随后向表中插入用户记录时，先把`用户记录`存储到这个`根节点` 中。
- 当根节点中的可用 `空间用完时` 继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 `页a` 中，然后对这个新页进行 `页分裂` 的操作，得到另一个新页，比如`页b` 。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 `页a` 或者 `页b` 中，而 `根节点` 便升级为存储`目录项`记录的页。

这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建一个索引，那么它的根节点的页号便会被记录到某个地方。然后凡是 `InnoDB` 存储引擎需要用到这个索引的时候，都会从哪个固定的地方取出根节点的页号，从而来访问这个索引。

>节点之间是双向链表 节点内部 是单向链表


#### 2. 内节点中目录项记录的唯一性

内节点也就是非叶子节点

我们知道B+树索引的内节点中目录项记录的内容是 `索引列 + 页号` 的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿 index_demo 表为例，假设这个表中的数据是这样的：


|  c1    |     c2    |     c3      |
| ---- | --------- | ---------- |
|  1   |    1      |    'u'       |
|  3   |    1      |    'd'       |
|  5   |    1      |    'y'       |
|  7   |    1      |    'a'       |

如果二级索引中目录项记录的内容只是 `索引列 + 页号` 的搭配的话，那么为 `c2` 列建立索引后的B+树应该长这样：

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-18_20-55-49.png)


如果我们想新插入一行记录，其中 `c1` 、`c2` 、`c3` 的值分别是: `9、1、c`, 那么在修改这个为 c2 列建立的二级索引对应的 B+树时便碰到了个大问题：由于 `页3` 中存储的目录项记录是由 `c2列 + 页号` 的值构成的，`页3` 中的两条目录项记录对应的 `c2列`的值都是1，而我们 新插入的这条记录的 `c2 列` 的值也是 1，那我们这条新插入的记录到底应该放在 `页4` 中，还是应该放在 `页5` 中？答案：对不起，懵了

为了让新插入记录找到自己在那个页面，我们需要**保证在B+树的同一层页节点的目录项记录除页号这个字段以外是唯一的**。所以对于二级索引的内节点的`目录项`记录的内容实际上是由三个部分构成的：
- 索引列的值
- 主键值
- 页号

也就是我们把`主键值`也添加到二级索引`内节点`中的`目录项`记录，这样就能保住 B+ 树每一层节点中各条`目录项`记录除页号这个字段外是唯一的，所以我们为c2建立二级索引后的示意图实际上应该是这样子的：

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-18_21-00-41.png)

这样我们再插入记录`(9, 1, 'c')` 时，由于 `页3` 中存储的目录项记录是由 `c2列 + 主键 + 页号` 的值构成的，可以先把新纪录的 `c2 列`的值和 `页3` 中各目录项记录的 `c2 列`的值作比较，如果 c2 列的值相同的话，可以接着比较主键值，因为B+树同一层中不同`目录项`记录的 `c2列 + 主键的值`肯定是不一样的，所以最后肯定能定位唯一的一条`目录项`记录，在本例中最后确定新纪录应该被插入到 `页5` 中。





#### 3. 一个页面最少存储 2 条记录

一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常多，而且最后的那个存放真实数据的目录中只存放一条数据。所以 **InnoDB 的一个数据页至少可以存放两条记录**。

---

### MyISAM中的索引方案


B树索引适用存储引擎如表所示：
|    索引 / 存储引擎       |MyISAM|InnoDB|Memory|
|-----------|-------|-------|--------|
|  B+Tree索引      |  支持  |  支持  |  支持   |

即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。

MyISAM引擎使用 `B+Tree` 作为索引结构，叶子节点的data域存放的是 `数据记录的地址` 。而InnoDB叶子节点存的就要看你是聚簇索引还是非局促索引了。


#### MyISAM索引的原理

MyISAM中是没有聚簇索引的，全部都可以理解为二级索引。并且数据与索引是分开存储的，`.MYD`存储数据`.MYI`存储索引。而InnoDB中我们说的是`数据即索引，索引即数据`，就是索引和数据都是存储在一个`.ibd`文件中。

我们知道 `InnoDB中索引即数据`，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了而 `MyISAM` 的索引方案虽然也使用树形结构，但是却 `将索引和数据分开存储`:
- 将表中的记录 `按照记录的插入顺序` 单独存储在一个文件中，称之为 `数据文件`。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并 `没有刻意按照主键大小排序`，所以我们并不能在这些数据上使用二分法进行查找。
- 使用 `MyISAM` 存储引擎的表会把索引信息另外存储到一个称为 `索引文件` 的另一个文件中。 `MyISAM` 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是 `主键值 + 数据记录地址`的组合。

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-18_21-57-32.png)

这里设表一共有三列，假设我们以Col1为主键，上图是一个MyISAM表的主索引(Primary key)示意。可以看出`MyISAM的索引文件仅仅保存数据记录的地址`。在MyISAM中，主键索引和二级索引(Secondary key)在结构上没有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复。如果我们在Co12上建立一个二级索
引，则此索引的结构如下图所示:

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-18_21-59-35.png)


同样也是一棵`B+Tree`，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为:首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，直接去`.MYD文件`中读取相应数据记录。



### MyISAM 与 InnoDB对比


MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：

① 在InnoDB存储引擎中，我们只需要根据主键值对 `聚簇索引` 进行一次查找就能找到对应的记录，而在 `MyISAM` 中却需要进行一次 `回表` 操作，意味着MyISAM中建立的索引相当于全部都是 `二级索引` 。

② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是`分离的` ，索引文件仅保存数据记录的地址。

③ InnoDB的非聚簇索引data域存储`相应记录`及 `主键的值` ，而MyISAM索引记录的是 `地址` 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。

④ MyISAM的回表操作是十分 `快速` 的，因为是拿着地址偏移量直接到`.MYD文件`中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。

⑤ InnoDB要求表 必须有主键 （ `MyISAM可以没有` ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个`隐含字段`作为主键，这个字段长度为6个字节，类型为长整型。


---

**小结：**

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如:

举例1: 知道了InnoDB的索引实现后，就很容易明白`为什么不建议使用过长的字段作为主键`，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。

举例2: 用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree，非单调的主键会造成在插入新记录时，数据文件为了维持B+Tree的特性而频繁的`页分裂`，`记录移动`，并且还会导致随机磁盘IO，十分低效，而使用自增字段作为主键则是一个很好的选择。


![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-18_22-10-16.png)


### 索引的代价

索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：

- 空间上的代价

    每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个`数据页`，一个页默认会 占用 `16KB` 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。

- 时间上的代价

    每次对表中的数据进行 `增、删、改` 操作时，都需要去修改各个`B+树`索引。而且我们讲过，B+树每层节点都是按照索引列的值 `从小到大的顺序排序` 而组成了 `双向链表` 。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是`用户记录`还是`目录项记录`）都是按照索引列的值从小到大的顺序 而形成了一个`单向链表`。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些 `记录移位` ， `页面分裂` 、 `页面回收` 等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。

>一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。




---

### MySQL数据结构选择的合理性


从MySQL的角度讲，不得不考虑一个现实问题就是磁盘IO。如果我们能让索引的数据结构尽量减少硬盘的 I/0 操作，所消耗的时间也就越小。可以说，`磁盘的I/0 操作次数` 对索引的使用效率至关重要。

查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内容的占用，`数据库索引是存储在外部磁盘上的`。当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能 `逐一加载`，那么MySQL衡量查询效率的标准就是磁盘I0次数。

#### 1. 全表查询
这里都懒得说了。

#### 2. Hash查询

Hash 本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。

Hash 算法是通过某种确定性的算法（比如 MD5、SHA1、SHA2、SHA3）将输入转变为输出。`相同的输入永远可以得到相同的输出`，假设输入内容有微小偏差，在输出中通常会有不同的结果。

举例：如果你想要验证两个文件是否相同，那么你不需要把两份文件直接拿来比对，只需要让对方把 Hash 函数计算得到的结果告诉你即可，然后在本地同样对文件进行 Hash 函数的运算，最后通过比较这两个 Hash 函数的结果是否相同，就可以知道这两个文件是否相同。

**加快查找速度的数据结构，常见的有两类：**

(1) 树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是`O(log2N)`;

(2) 哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是 `O(1)`; (key, value)

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-18_23-10-42.png)

采用 Hash 进行检索效率非常高，基本上一次检索就可以找到数据，而 B+ 树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次 I/O 操作，`从效率来说 Hash 比 B+ 树更快`。

在哈希的方式下，一个元素k处于h(k)中，即利用哈希函数h，根据关键字k计算出槽的位置。函数h将关键字域映射到哈希表`T[0…m-1]`的槽位上。

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-18_23-12-27.png)

上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 `碰撞` ，在数据库中一般采用 `链接法` 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-18_23-12-55.png)

实验：体会数组和hash表的查找方面的效率区别
```java
// 算法复杂度为 O(n)
@Test
public void test1(){
    int[] arr = new int[100000];
    for(int i = 0;i < arr.length;i++){
        arr[i] = i + 1;
    }
    long start = System.currentTimeMillis();
    for(int j = 1; j<=100000;j++){
        int temp = j;
        for(int i = 0;i < arr.length;i++){
            if(temp == arr[i]){
                break;
            }
        }
    }
    long end = System.currentTimeMillis();
    System.out.println("time： " + (end - start)); //time： 823ms
}
```

```java
// 算法复杂度为 O(1)
@Test
public void test2(){
    HashSet<Integer> set = new HashSet<>(100000);
    for(int i = 0;i < 100000;i++){
    	set.add(i + 1);
    }
    long start = System.currentTimeMillis();
    for(int j = 1; j<=100000;j++) {
        int temp = j;
        boolean contains = set.contains(temp);
    }
    long end = System.currentTimeMillis();
    System.out.println("time： " + (end - start)); //time： 5ms
}
```

Hash结构效率高，那为什么索引结构要设计成树型呢？

原因1: `Hash 索引`仅能满足`(=)` `(<>)`和`IN`查询。如果进行范围查询,哈希型的索引,时间复杂度会退化为`O(n)`; 而树型的"有序"特性, 依然能够保持`O(log2N)`的高效率。

原因2: Hash 索引还有一个缺陷,数据的存储是`没有顺序的`,在`ORDER BY`的情况下,使用 `Hash 索引`还需要对数据重新排序。

原因3: 对于联合索引的情况,Hash 值是将联合索引键`合并后一起来计算的`,无法对单独的一个键或者几个索引键进行查询。多字段联合索引的B+树仍然可以通过单个字段来查。Hash方式则不行。如果是树形的，联合索引可以单独使用C3，而Hash只能同时用C2和C3。

原因4: 对于等值查询来说,通常 Hash 索引的效率更高,不过也存在一种情况,就是索引列的重复值如果很多,效率就会降低。这是因为遇到 Hash 冲突时,需要遍历桶中的行指针来进行比较,找到查询的关键字,非常耗时。所以,Hash 索引通常不会用到重复值多的列上,比如列为性别、年龄的情况等。

Hash索引适用存储引擎如表所示：

|索引 / 存储引擎|MyISAM	|InnoDB|Memory
|-----|------|------|------|
|HASH索引	| 不支持	| 不支持| 	支持


Hash索引的适用性：

Hash 索引存在着很多限制，相比之下在数据库中 B+ 树索引的使用面会更广，不过也有一些场景采用 Hash 索引效率更高，比如在键值型（Key-Value）数据库中，`Redis 存储的核心就是 Hash 表`。

`MySQL` 中的 `Memory` 存储引擎支持` Hash 存储`，如果我们需要用到查询的临时表时，就可以选择 Memory 存储引擎，把某个字段设置为 `Hash 索引`，比如字符串类型的字段，进行 `Hash 计算`之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行等值查询的时候，采用 `Hash 索引`是个不错的选择。

另外，InnoDB 本身不支持 `Hash 索引`，但是提供`自适应 Hash 索引`（Adaptive Hash Index）。什么情况下才会使用自适应 Hash 索引呢？如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到 `Hash 表`中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让 `B+ 树`也具备了 Hash 索引的优点。

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-18_23-25-27.png)


采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显提高数据的检索效率。

我们可以通过 `innodb_adaptive_hash_index` 变量来查看是否开启了`自适应 Hash`，比如：
```sql
show variables like '%adaptive_hash_index';
```




#### 3. 二叉搜索树

如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。

1. 二叉搜索树的特点
    - 一个节点只能有两个子节点，也就是一个节点度不能超过2
    - 左子节点 < 本节点; 右子节点 >= 本节点，比我大的向右，比我小的向左

2. 查找规则

我们先来看下最基础的二叉搜索树（Binary Search Tree），搜索某个节点和插入节点的规则一样，我们假设搜索插入的数值为 key：
1. 如果 key 大于根节点，则在右子树中进行查找；
2. 如果 key 小于根节点，则在左子树中进行查找；
3. 如果 key 等于根节点，也就是找到了这个节点，返回根节点即可。
举个例子，我们对数列（34，22，89，5，23，77，91）创造出来的二分查找树如下图所示：

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-21_21-43-54.png)


但是特殊情况，就是有时候二叉树的深度非常大，比如：

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-21_21-46-19.png)

为了提高查询效率，就需要 `减少磁盘IO数` 。为了减少磁盘IO的次数，就需要尽量 `降低树的高度` ，需要把 原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。

#### 4. AVL树

为了解决上面二叉查找树退化成链表的问题，人们提出了`平衡二叉搜索树（Balanced Binary Tree）`，又称为AVL树（有别于AVL算法），它在二叉搜索树的基础上增加了约束，具有以下性质：

**它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树**。

这里说一下，常见的平衡二叉树有很多种，包括了`平衡二叉搜索树`、`红黑树`、`数堆`、`伸展树`。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是 `O(log2n)`。

数据查询的时间主要依赖于磁盘 I/O 的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是 `O(log2n)`，当 n 比较大时，深度也是比较高的，比如下图的情况：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-21_21-50-01.png)

**每访问一次节点就需要进行一次磁盘 I/O 操作**，对于上面的树来说，我们需要进行 5次 I/O 操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率。

针对同样的数据，如果我们把二叉树改成 M 叉树 （M>2）呢？当 M=3 时，同样的 31 个节点可以由下面 的三叉树来进行存储：


![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-21_21-57-00.png)

你能看到此时树的高度降低了，当数据量 N 大的时候，以及树的分叉树 M 大的时候，M叉树的高度会远小于二叉树的高度 (M > 2)。所以，我们需要把 `树从“瘦高” 变 “矮胖”`。

5. B-Tree

B 树的英文是 `Balance Tree`，也就是 **多路平衡查找树**。简写为 `B-Tree`。它的高度远小于平衡二叉树的高度。

B 树的结构如下图所示：
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-21_21-59-26.png)

B 树作为*多路平衡查找树*，它的每一个节点最多可以包括 M 个子节点，`M 称为 B 树的阶`。每个磁盘块中包括了`关键字`和`子节点的指针`。如果一个磁盘块中包括了 x 个关键字，那么指针数就是 x+1。对于一个 100 阶的 B 树来说，如果有 3 层的话最多可以存储约 100 万的索引数据。对于大量的索引数据来说，采用 B 树的结构是非常适合的，因为树的高度要远小于二叉树的高度。

一个 M 阶的 B 树（M>2）有以下的特性：
1. 根节点的儿子数的范围是 `[2,M]`。
2. 每个中间节点包含 `k-1` 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为 `[ceil(M/2), M]`。
3. 叶子节点包括 `k-1` 个关键字（叶子节点没有孩子），k 的取值范围为 `[ceil(M/2), M]`。
4. 假设中间节点节点的关键字为：`Key[1]`, `Key[2]`, …, `Key[k-1]`，且关键字按照升序排序，即 `Key[i]<Key[i+1]`。此时 `k-1` 个关键字相当于划分了 `k` 个范围，也就是对应着 `k` 个指针，即为：`P[1]`,` P[2]`, …, `P[k]`，其中 `P[1]` 指向关键字小于 `Key[1]` 的子树，`P[i]` 指向关键字属于 `(Key[i-1], Key[i])` 的子树，`P[k]` 指向关键字大于 `Key[k-1]` 的子树。
所有叶子节点位于同一层。

上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。

:::tip
M 的含义，表示 B 树的阶数（Order of B-tree），**单个节点最多拥有的子节点数量**，必须是 >2 的整数（保证平衡性）。

k 的含义，表示 当前节点的子节点数量

P 的含义，表示 指向子树的指针（Pointer）

关键概念图解
```
          [中间节点: k=4个子节点]
         /         |       |       \
        ↓          ↓       ↓        ↓
关键字:   10       (10,30)   (30,50)  >50
指针:    P[1]      P[2]     P[3]    P[4]
        |          |        |       |
        ▼          ▼        ▼       ▼
     [子树]     [子树]    [子树]  [子树]
```
:::


然后我们来看下如何用 B 树进行查找。假设我们想要 `查找的关键字是 9` ，那么步骤可以分为以下几步：
1. 我们与根节点的关键字 `(17，35）`进行比较，9 小于 17 那么得到指针 P1；
2. 按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；
3. 按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。

你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比 较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行 比较所需要的时间要多，是数据查找用时的重要因素。 `B 树相比于平衡二叉树来说磁盘 I/O 操作要少` ， 在数据查询中比平衡二叉树效率要高。所以 `只要树的高度足够低，IO次数足够少，就可以提高查询性能` 。

**小结:**
1. B树在插入和删除节点的时候如果导致树不平衡,就通过自动调整节点的位置来保持树的自平衡。
2. 关键字集合分布在整棵树中,即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束
3. 其搜索性能等价于在关键字全集内做一次二分查找。


**再举例1：**
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-21_22-12-54.png)


#### 6. B+Tree

B+ 树也是一种多路搜索树，`基于 B 树做出了改进`，主流的 DBMS 都支持 B+ 树的索引方式，比如 MySQL。相比于 B-Tree，`B+Tree 适合文件索引系统`。



**B+ 树和 B 树的差异在于以下几点：**
1. 有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数 +1。
2. `B+Tree`非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。
3. 非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， `非叶子节点既保存索引，也保存数据记录` 。
4. 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。

下图就是一棵 B+ 树，阶数为 3，根节点中的关键字 1、18、35 分别是子节点（1，8，14），（18，24，31）和（35，41，53）中的最小值。每一层父节点的关键字都会出现在下一层的子节点的关键字中，因此在叶子节点中包括了所有的关键字信息，并且每一个叶子节点都有一个指向下一个节点的指针，这样就形成了一个链表。
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-21_22-21-12.png)


比如，我们想要查找关键字 16，`B+ 树`会自顶向下逐层进行查找：
1. 与根节点的关键字 (1，18，35) 进行比较，16 在 1 和 18 之间，得到指针 P1 (指向磁盘块 2)
2. 找到磁盘块 2，关键字为 (1，8，14)，因为 16 大于 14，所以得到指针 P3 (指向磁盘块 7)
3. 找到磁盘块 7，关键字为 (14，16，17)，然后我们找到了关键字 16，所以可以找到关键字 16 所对应的数
据。

整个过程一共进行了3次`I/O操作`，看起来`B+树`和`B树`的查询过程差不多，但是B+树和B树有个根本的差异在于，`B+树的中间节点并不直接存储数据`。这样的好处都有什么呢？

首先，`B+树查询效率更稳定`。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。

其次，`B+树的查询效率更高`。这是因为通常B+树比B树`更矮胖`（阶数更大，深度更低），查询所需要的磁盘I/O也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。

不仅是对单个关键字的查询上，`在查询范围上，B+树的效率也比B树高`。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。


>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。 但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。

---

思考题：为了减少IO，索引树会一次性加载吗？

>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。
>
>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。

思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO
>InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用 4 个字节）或 BIGINT（占用 8 个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 16KB/(8B+8B)=1K 个键值（因为是估值，为方便计算，这里的 K 取值为 10^3。也就是说一个深度为 3 的 B+Tree 索引可以维护 10^3 * 10^3 * 10^3 = 10 亿条记录。(这里假定一个数据页也存储 10^3 条行记录数据了)
>
>实际情况中每个节点可能不能填满，因此在数据库中， B+Tree 的高度一般都在 2~4 层 。MySQL 的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I/O 操作。


思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？
>1、B+树的磁盘读写代价更低  
>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
>
>2、B+树的查询效率更加稳定  
>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。


思考题：Hash 索引与 B+ 树索引的区别
>1、Hash 索引`不能进行范围查询`，而 B+ 树可以。这是因为 Hash 索引指向的数据是无序的，而 B+ 树的叶子节点是个有序的链表。
>
>2、Hash 索引`不支持联合索引的最左侧原则`（即联合索引的部分索引无法使用），而 B+ 树可以。对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。
>
>3、Hash 索引`不支持 ORDER BY 排序`，因为 Hash 索引指向的数据是无序的，因此无法起到排序优化的作用，而 B+ 树索引数据是有序的，可以起到对该字段 ORDER BY 排序优化的作用。同理，我们也无法用 Hash 索引进行模糊查询，而 B+ 树使用 LIKE 进行模糊查询的时候，LIKE 后面后`模糊查询`（比如 % 结尾）的话就可以起到优化作用。
>
>4、`InnoDB 不支持哈希索引`

思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？
>你能看到，针对 InnoDB 和 MyISAM 存储引擎，都会默认采用 B+ 树索引，无法使用 Hash 索引。InnoDB 提供的自适应 Hash 是不需要手动指定的。如果是 Memory/Heap 和 NDB 存储引擎，是可以进行选择 Hash 索引的。


#### 7. R树

R-Tree在MySQL很少使用，仅支持 geometry数据类型 ，支持该类型的存储引擎只有myisam、bdb、 innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子：查找20英里以内所有的餐厅。如果 没有R树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记 录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满 足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度 地图这种超大数据库中，这种方法便必定不可行了。R树就很好的 解决了这种高维空间搜索问题 。它把B 树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解 结点的方法，保证树的平衡性。因此，R树就是一棵用来 存储高维数据的平衡树 。相对于B-Tree，R-Tree 的优势在于范围查找。


|索引 / 存储引擎 | 	MyISAM |	InnoDB |	Memory|
|-------|----------|-----------|---------|
|R-Tree索引	|支持|	支持	|不支持|


#### 小结

使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利（提升查询效率）和弊（维护索引所需的代价）。

在实际工作中，我们还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管`索引不是万能的`，但`数据量大的时候不使用索引是不可想象的`，毕竟索引的本质，是帮助我们提升数据检索的效率。


附录：算法的时间复杂度
![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-21_23-06-28.png)




## 索引的创建与设计原则


### 索引声明与使用

#### 索引的分类

MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。

- 从 `功能逻辑` 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。
- 按照 `物理实现方式` ，索引可以分为 2 种：聚簇索引和非聚簇索引。
- 按照 `作用字段个数` 进行划分，分成单列索引和联合索引。



1. 普通索引

    在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在`任何数据类型中`，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表`student`的字段`name`上建立一个普通索引，查询记录时就可以根据该索引进行查询。

2. 唯一性索引

    使用`UNIQUE参数`可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里`可以有多个`唯一索引。
    例如，在表student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯一性索引，可以更快速地确定某条记录。

3. 主键索引

    主键索引就是一种`特殊的唯一性索引`，在唯一索引的基础上增加了不为空的约束，也就是`NOT NULL+UNIQUE`，一张表里`最多只有一个`主键索引。

   ` Why？`这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。


4. 单列索引

    在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以**有多个**单列索引。

5. 多列 (组合、联合) 索引

    多列索引是在表的**多个字段组合**上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段 id、name 和 gender 上建立一个多列索引 `idx_id_name_gender`，只有在查询条件中使用了字段 id 时该索引才会被使用。使用组合索引时遵循 **最左前缀集合**。

6. 全文检索
全文索引 (也称全文检索) 是目前**搜索引擎**使用的一种关键技术。它能够利用【`分词技术`】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。

使用参数 `FULLTEXT` 可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在 `CHAR`、 `VARCHAR` 或 `TEXT` 类型及其系列类型的字段上，**查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度**。例如，表 `student` 的字段 `information` 是 `TEXT` 类型，该字段包含了很多文字信息。在字段 `information`上建立全文索引后，可以提高查询字段 information的速度。

全文索引典型的有两种类型：自然语言的全文索引和布尔全文索引。

- 自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。**在整个索引中出现次数越少的词语，匹配时的相关度就越高**。相反，非常常见的单词将不会被搜索，如果一个词语的在超过 50% 的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。

MySQL数据库从`3.23.23`版开始支持全文索引，但`MySQL5.6.4`以前`只有Myisam支持`，5.6.4版本以后`innodb才支持`，但是官方版本不支持`中文分词`，需要第三方分词插件。在5.7.6版本，MySQL内置了`ngram全文解析器`，用来支持亚洲语种的分词。测试或使用全文索引时，要先看一下自己的MySQL版本、存储引擎和数据类型是否支持全文索引。

随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被`solr`、`ElasticSearch`等专门的搜索引擎所替代。

7. 补充：空间索引

    使用参数`SPATIAL`可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括`GEOMETRY`、`POINT`、`LINESTRING`和`POLYGON`等。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。

**小结：不同的存储引擎支持的索引类型也不一样**

- InnoDB：支持 B-tree、Full-text 等索引，不支持 Hash 索引；
- MyISAM： 支持 B-tree、Full-text 等索引，不支持 Hash 索引；
- Memory：支持 B-tree、Hash 等 索引，不支持 Full-text 索引；
- NDB：支持 Hash 索引，不支持 B-tree、Full-text 等索引；
- Archive：不支持 B-tree、Hash、Full-text 等索引；


#### 创建索引

MySQL支持多种方法在单个或多个列上创建索引：在创建表的定义语句 CREATE TABLE 中指定索引列，使用 ALTER TABLE 语句在存在的表上创建索引，或者使用 CREATE INDEX 语句在已存在的表上添加索引。

##### 创建表的时候创建索引

使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。


举例：
```sql
CREATE TABLE dept
(
    dept_id   BIGINT PRIMARY KEY AUTO_INCREMENT,
    dept_name VARCHAR(20)
);

# 隐式的方式创建索引。在声明有主键约束、唯一性约束、外键约束的字段上，会自动的添加相关的索引
CREATE TABLE emp
(
    emp_id   BIGINT AUTO_INCREMENT PRIMARY KEY,
    emp_name VARCHAR(20) UNIQUE,
    dept_id  BIGINT,
    CONSTRAINT emp_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (dept_id)
);
```

但是，如果显式创建表时创建索引的话，基本语法格式如下：
```sql
CREATE TABLE table_name [col_name data_type]
[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]
```

- UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引；
- INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引；
- index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；
- col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；
- length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；
- ASC 或 DESC 指定升序或者降序的索引值存储。



1. 创建普通索引

```sql
# 显示创建索引
CREATE TABLE book
(
    book_id          INT,
    book_name        VARCHAR(100),
    authors          VARCHAR(100),
    info             VARCHAR(100),
    comment          VARCHAR(100),
    year_publication YEAR,
    # 声明索引
    INDEX idx_bname (book_name)
);

```

*命令查看索引*
```sql
# 方式1
SHOW CREATE TABLE book;

# 方式2
SHOW INDEX FROM book;
# Non_unique字段表示是否不是唯一约束，1true 0false 1表示非唯一的 0唯一的
```

2. 创建唯一索引
```sql
# 创建唯一索引
# 声明有唯一索引的字段，在添加数据时，要保证唯一性，但是可以添加null
CREATE TABLE book1
(
    book_id          INT,
    book_name        VARCHAR(100),
    authors          VARCHAR(100),
    info             VARCHAR(100),
    comment          VARCHAR(100),
    year_publication YEAR,
# 声明索引
    UNIQUE INDEX uk_idx_cmt (comment)
);

SHOW INDEX FROM book1;
```

3. 主键索引
```sql
# 主键索引
# 通过定义主键约束的方式定义主键索引
CREATE TABLE book2
(
    book_id          INT PRIMARY KEY,
    book_name        VARCHAR(100),
    authors          VARCHAR(100),
    info             VARCHAR(100),
    comment          VARCHAR(100),
    year_publication YEAR
);

show index from book2;

# 通过删除主键约束的方式删除主键索引
ALTER TABLE book2
    DROP PRIMARY KEY;

# 修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引
```

4. 创建单列索引
```sql
# 创建单列索引
CREATE TABLE book3
(
    book_id          INT PRIMARY KEY,
    book_name        VARCHAR(100),
    authors          VARCHAR(100),
    info             VARCHAR(100),
    comment          VARCHAR(100),
    year_publication YEAR,
    UNIQUE INDEX idx_name (book_name)
);

show index from book3;
```


5. 创建组合索引
```sql
# 创建联合索引
CREATE TABLE book4
(
    book_id          INT PRIMARY KEY,
    book_name        VARCHAR(100),
    authors          VARCHAR(100),
    info             VARCHAR(100),
    comment          VARCHAR(100),
    year_publication YEAR,
    INDEX mul_bid_bname_info (book_id, book_name, info)
);
# Seq_in_index 是有序的，按照创建时指定的联合索引的顺序来的
show index from book4;
# 联合索引遵循 最左前缀原则，(带头大哥不能死，中间兄弟不能断)
```

6. 创建全文索引

FULLTEXT全文索引可以用于全文检索，并且只为 CHAR 、VARCHAR 和 TEXT 列创建索引。索引总是对整个列进行，不支持局部 (前缀) 索引。

举例1：创建表test4，在表中的info字段上建立全文索引，SQL语句如下：

```sql
CREATE TABLE test4(
id INT NOT NULL,
name CHAR(30) NOT NULL,
age INT NOT NULL,
info VARCHAR(255),
FULLTEXT INDEX futxt_idx_info(info(50))
) ENGINE=MyISAM;

# 该全文索引意味着只给每行info的前50个字符创建索引，那么在b+tree中，每页存储的数据将会更多

show index from test4;
# 由结果可以看到，info字段上已经成功建立了一个名为futxt_idx_info的FULLTEXT索引。
```
>mysql5.5只有myisam支持，innodb不支持; 在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。


举例2：
```sql
CREATE TABLE articles (
id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
title VARCHAR (200),
body TEXT,
FULLTEXT index (title, body)
) ENGINE = INNODB;
```
创建了一个给title和body字段添加全文索引的表。

举例3：
```sql
CREATE TABLE `papers` (
`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
`title` varchar(200) DEFAULT NULL,
`content` text,
PRIMARY KEY (`id`),
FULLTEXT KEY `title` (`title`,`content`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
```
不同于like方式的的查询：
```sql
SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’;
```
全文索引用match+against方式查询：
```sql
SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);
```
明显的提高查询效率。
>注意点
>   1. 使用全文索引前，搞清楚版本支持情况；
>   2. 全文索引比 like + % 快 N 倍，但是可能存在精度问题；
>   3. 如果需要全文索引的是大量数据，建议先添加数据，再创建索引。



7. 创建空间索引
空间索引创建中，要求空间类型的字段必须为 非空 。

举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：

```sql
CREATE TABLE test5(
geo GEOMETRY NOT NULL,
SPATIAL INDEX spa_idx_geo(geo)
) ENGINE=MyISAM;

SHOW INDEX FROM test5
```
可以看到，test5表的geo字段上创建了名称为`spa_idx_geo`的空间索引。注意创建时指定空间类型字段值的非空约束，并且表的存储引擎为**MyISAM**。


##### 在已经存在的表上创建索引

在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。

1. 使用ALTER TABLE语句创建索引 ALTER TABLE语句创建索引的基本语法如下：
```sql
ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]
[index_name] (col_name[length],...) [ASC | DESC]
```

2. 使用CREATE INDEX创建索引 CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中， CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为：
```sql
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
ON table_name (col_name[length],...) [ASC | DESC]
```

示例
```sql
alter table 表名 add index 索引名 (字段名(长度))
ALTER TABLE book5
    ADD INDEX idx_cmt (comment);

ALTER TABLE book5
    ADD UNIQUE INDEX uk_idx_bname (book_name);


ALTER TABLE book5
    ADD INDEX mul_bid_bname_info (book_id, book_name, info);

CREATE INDEX idx_cmt ON book5(comment);
```

#### 删除索引

1. 使用ALTER TABLE删除索引 ALTER TABLE删除索引的基本语法格式如下：
```sql
ALTER TABLE table_name DROP INDEX index_name;
```
2. 使用DROP INDEX语句删除索引 DROP INDEX删除索引的基本语法格式如下：
```sql
DROP INDEX index_name ON table_name;
```

:::tip
删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。

添加AUTO_INCREMENT约束字段的唯一索引不能删除，AUTO_INCREMENT要么有主键约束要么有唯一约束；
:::

```sql
# 索引的删除
ALTER TABLE book5
    DROP index idx_cmt;

DROP INDEX uk_idx_bname ON book5;
```

### MySQL8.0索引新特性

#### 1. 支持降序索引

    降序索引以降序存储键值。虽然在语法上，从MySQL 4版本开始就已经支持降序索引的语法了，但实际上DESC定义是被忽略的，直到MySQL 8.x版本才开始真正支持降序索引 (仅限于InnoDB存储引擎)。

    MySQL在8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。

    举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：
```sql
CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));
```

在MySQL 5.7版本中查看数据表ts1的结构，结果如下:

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-22_23-14-05.png)

从结果可以看出，索引仍然是默认的升序

在MySQL 8.0版本中查看数据表ts1的结构，结果如下：

![](https://zzyang.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2025-07-22_23-14-45.png)

从结果可以看出，索引已经是降序了。下面继续测试降序索引在执行计划中的表现。

分别在MySQL 5.7版本和MySQL 8.0版本的数据表ts1中插入800条随机数据，执行语句如下：
```sql
DELIMITER //
CREATE PROCEDURE ts_insert()
BEGIN
	DECLARE i INT DEFAULT 1;
	WHILE i < 800
	DO
		insert into ts1 select rand()*80000, rand()*80000;
		SET i = i+1;
	END WHILE;
	commit;
END //
DELIMITER;

# 调用
CALL ts_insert();
```
在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下:
```sql
EXPLAIN SELECT * FROM ts1 ORDER BY a, b DESC LIMIT 5;
```
在MySQL 8.0版本中查看数据表 ts1 的执行计划。

从结果可以看出，修改后MySQL 5.7 的执行计划要明显好于MySQL 8.0。


#### 2. 隐藏索引


在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发展删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较 大，这种操作就会消耗系统过多的资源，操作成本非常高。

从MySQL 8.x开始支持 隐藏索引（invisible indexes） ，只需要将待删除的索引设置为隐藏索引，使 查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引）， 确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。

同时，如果你想验证某个索引删除之后的 查询性能影响，就可以暂时先隐藏该索引。

:::warning
主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。
:::

索引默认是可见的，在使用CREATE TABLE, CREATE INDEX 或者 ALTER TABLE 等语句时可以通过 VISIBLE 或者 INVISIBLE 关键词设置索引的可见性。


1. 创建表时直接创建

在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下：
```sql
CREATE TABLE tablename(
propname1 type1[CONSTRAINT1],
propname2 type2[CONSTRAINT2],
……
propnamen typen,
INDEX [indexname](propname1 [(length)]) INVISIBLE
);
```
上述语句比普通索引多了一个关键字INVISIBLE，用来标记索引为不可见索引。

示例：
```sql
# 隐藏索引（创建表时隐藏索引）
CREATE TABLE book6
(
    book_id          INT PRIMARY KEY,
    book_name        VARCHAR(100),
    authors          VARCHAR(100),
    info             VARCHAR(100),
    comment          VARCHAR(100),
    year_publication YEAR,
    INDEX idx_cmt (comment) INVISIBLE
);
```

2. 在已经存在的表上创建

可以为已经存在的表设置隐藏索引，其语法形式如下：
```sql
CREATE INDEX indexname
ON tablename(propname[(length)]) INVISIBLE;
```
示例：
```sql
CREATE INDEX idx_year_pub ON book6 (year_publication) INVISIBLE;
```

3. 通过ALTER TABLE语句创建

语法形式如下：
```sql
ALTER TABLE tablename
ADD INDEX indexname (propname [(length)]) INVISIBLE;
```
示例：
```sql
ALTER TABLE book6
    ADD UNIQUE INDEX uk_idx_bname (book_name) INVISIBLE;
```


4. 切换索引可见状态

已存在的索引可通过如下语句切换可见状态：
```sql
ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引
ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引
```

如果将index_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index_cname索引。

:::tip
当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。
:::
通过设置隐藏索引的可见性可以查看索引对调优的帮助。


5. 使隐藏索引对查询优化器可见

在`MySQL 8.x`版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关 (`use_invisible_indexes`) 来打开某个设置，使隐藏索引对查询优化器可见。如果`use_invisible_indexes` 设置为`off (默认)`，优化器会忽略隐藏索引。如果设置为`on`，即使隐藏索引不可见，优化器在生成执行计 划时仍会考虑使用隐藏索引。

（1）在MySQL命令行执行如下命令查看查询优化器的开关设置。
```sql
select @@optimizer_switch \G
```
在输出的结果信息中找到如下属性配置。
```
use_invisible_indexes=off
```
此属性配置值为off，说明隐藏索引默认对查询优化器不可见。

（2）使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令：
```sql
set session optimizer_switch="use_invisible_indexes=on";
```
SQL语句执行成功，再次查看查询优化器的开关设置。

```sql
mysql> select @@optimizer_switch \G
*************************** 1. row ***************************
@@optimizer_switch:
index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_
intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_co
st_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on
,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on
,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_ind
exes=on,skip_scan=on,hash_join=on
1 row in set (0.00 sec)
```
此时，在输出结果中可以看到如下属性配置。
```sql
use_invisible_indexes=on
```
`use_invisible_indexes`属性的值为`on`，说明此时隐藏索引对查询优化器可见。

（3）使用EXPLAIN查看以字段invisible_column作为查询条件时的索引使用情况。
```sql
explain select * from classes where cname = '高一2班';
```
查询优化器会使用隐藏索引来查询数据。

（4）如果需要使隐藏索引对查询优化器不可见，则只需要执行如下命令即可。
```sql
set session optimizer_switch="use_invisible_indexes=off";
```
再次查看查询优化器的开关设置。
```sql
select @@optimizer_switch \G
```
此时，use_invisible_indexes属性的值已经被设置为“off”。


### 索引的设计原则

#### 数据准备

第1步：创建数据库、创建表
```sql
CREATE DATABASE atguigudb1;
USE atguigudb1;
#1.创建学生表和课程表
CREATE TABLE `student_info` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`student_id` INT NOT NULL ,
`name` VARCHAR(20) DEFAULT NULL,
`course_id` INT NOT NULL ,
`class_id` INT(11) DEFAULT NULL,
`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

CREATE TABLE `course` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`course_id` INT NOT NULL ,
`course_name` VARCHAR(40) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

第2步：创建模拟数据必需的存储函数
```sql
#函数1：创建随机产生字符串函数
DELIMITER //
CREATE FUNCTION rand_string(n INT)
	RETURNS VARCHAR(255) #该函数会返回一个字符串
BEGIN
	DECLARE chars_str VARCHAR(100) DEFAULT
'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
	DECLARE return_str VARCHAR(255) DEFAULT '';
    DECLARE i INT DEFAULT 0;
    WHILE i < n DO
    	SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
    	SET i = i + 1;
    END WHILE;
    RETURN return_str;
END //
DELIMITER ;
```
```sql
#函数2：创建随机数函数
DELIMITER //
CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)
BEGIN
DECLARE i INT DEFAULT 0;
SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;
RETURN i;
END //
DELIMITER ;
```
创建函数，假如报错：
```
This function has none of DETERMINISTIC......
```
由于开启过慢查询日志bin-log, 我们就必须为我们的function指定一个参数。

主从复制，主机会将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据。如果使 用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql不开启创建函数设置。

- 查看mysql是否允许创建函数：
```sql
show variables like 'log_bin_trust_function_creators';
```
- 命令开启：允许创建函数设置：
```sql
set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。
```
- mysqld重启，上述参数又会消失。永久方法：

    - windows下：my.ini[mysqld]加上：
    ```
    log_bin_trust_function_creators=1
    ```
    - linux下：/etc/my.cnf下my.cnf[mysqld]加上：
    ```
    log_bin_trust_function_creators=1
    ```

第3步：创建插入模拟数据的存储过程
```sql
# 存储过程1：创建插入课程表存储过程
DELIMITER //
CREATE PROCEDURE insert_course( max_num INT )
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0; #设置手动提交事务
REPEAT #循环
SET i = i + 1; #赋值
INSERT INTO course (course_id, course_name ) VALUES
(rand_num(10000,10100),rand_string(6));
UNTIL i = max_num
END REPEAT;
COMMIT; #提交事务
END //
DELIMITER ;
```

```sql
# 存储过程2：创建插入学生信息表存储过程
DELIMITER //
CREATE PROCEDURE insert_stu( max_num INT )
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0; #设置手动提交事务
REPEAT #循环
SET i = i + 1; #赋值
INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES
(rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));
UNTIL i = max_num
END REPEAT;
COMMIT; #提交事务
END //
DELIMITER ;
```

第4步：调用存储过程
```sql
CALL insert_course(100);
```
```sql
CALL insert_stu(1000000);
```